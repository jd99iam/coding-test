# 내 풀이 분석
- 가중치가 없는 상황에서 최단거리를 구하라고 해서 BFS를 떠올림 (O)
- 순회 (bfs) 는 어차피 O(N) 이므로 시간복잡도는 문제 없다고 판단함 (O)
- 상, 하, 좌, 우 이동 각각의 경우에 대해 if문을 작성해서 매우 지저분함. dx, dy 배열을 사용하는 편이 나음
- x, y 가 x는 세로, y는 가로인데 매우 헷갈림
- bfs 특성상 최초로 방문했을 때가 최단거리이고, 어차피 한번 방문한 곳은 다시 방문하지 않음. visited 배열에 방문 안했으면 -1, 방문했으면 level 값을 넣고 있기 때문에 Node에 굳이 level 필드는 필요하지 않음

# 개선
```java
import java.util.*;

class Solution {

    public int solution(int[][] maps) {
        int n = maps.length;
        int m = maps[0].length;

        int[][] visited = new int[n][m];
        for (int i = 0; i < n; i++) {
            Arrays.fill(visited[i], -1);
        }

        // BFS Queue
        Queue<int[]> q = new ArrayDeque<>();

        // 시작점
        q.offer(new int[]{0, 0});
        visited[0][0] = 1;   // 이동 칸 수를 1부터 시작

        // 4방향 (오른쪽, 왼쪽, 아래, 위)
        int[] dx = {1, -1, 0, 0};
        int[] dy = {0, 0, 1, -1};

        while (!q.isEmpty()) {
            int[] cur = q.poll();
            int x = cur[0];
            int y = cur[1];
            int dist = visited[y][x];

            for (int i = 0; i < 4; i++) {
                int nx = x + dx[i];
                int ny = y + dy[i];

                // 범위 체크 + 벽 + 방문 여부
                if (nx < 0 || nx >= m || ny < 0 || ny >= n) continue;
                if (maps[ny][nx] == 0) continue;
                if (visited[ny][nx] != -1) continue;

                visited[ny][nx] = dist + 1;
                q.offer(new int[]{nx, ny});
            }
        }

        return visited[n-1][m-1];   // 도달 못하면 -1
    }
}

``` 
- dx, dy 사용으로 깔끔
- Node에 level 필드 사용하지 않고, visited에 기록하는 형식, 현재 level도 visited를 참조해서 알 수 있음(어차피 이미 방문한 지점이 큐에서 poll 되므로)
