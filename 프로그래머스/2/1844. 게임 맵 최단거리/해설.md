# 첫번째 풀이
통과는 했지만, 너무 복잡하게 작성했고, 디버깅이 힘들었다. 

- 가중치가 없는 상황에서 최단거리를 구하라고 해서 BFS를 떠올림 (O)
- 순회 (bfs) 는 어차피 O(N) 이므로 시간복잡도는 문제 없다고 판단함 (O)
- 상, 하, 좌, 우 이동 각각의 경우에 대해 if문을 작성해서 매우 지저분함. dx, dy 배열을 사용하는 편이 나음
- x, y 가 x는 세로, y는 가로인데 매우 헷갈림
- bfs 특성상 최초로 방문했을 때가 최단거리이고, 어차피 한번 방문한 곳은 다시 방문하지 않음. visited 배열에 방문 안했으면 -1, 방문했으면 level 값을 넣고 있기 때문에 Node에 굳이 level 필드는 필요하지 않음

# 개선 버전 (최신 커밋)
```java

/**

가중치 없는 최단거리 문제이므로 bfs 사용 
시간복잡도는 O(N), N 최대 10^4이므로 문제 X 

visited 2차원 배열 
- 방문하지 않은 곳 : -1 (생성 후 -1로 fill)
- 방문한 곳 : level 값 (이동 거리)

4방향 표현 위해 dx, dy 배열 사용 

**/

import java.util.*;


class Solution {
    
    private static class Node {
        int x;
        int y;
        
        public Node(int x, int y, int level){
            this.x = x; 
            this.y = y; 
        }
    }
    
    public int solution(int[][] maps) {
        return bfs(maps);
    }
    
    public int bfs(int[][] maps){
        ArrayDeque<Node> q = new ArrayDeque<>();
        
        int n = maps.length;
        int m = maps[0].length;
        
        int[][] visited = new int[n][m];
        
        for (int i=0; i<n; i++){
                  Arrays.fill(visited[i],-1);
        }

        q.offer(new Node(0,0,1));
        visited[0][0] = 1;
        
        // 4방향 표현 위함
        int[] dx = {1, -1, 0, 0};
        int[] dy = {0, 0, 1, -1};
                
        while (!q.isEmpty()){
            Node current = q.poll();
            int x = current.x;
            int y = current.y;
            int l = visited[y][x];
            
            
            for (int i=0; i<4; i++){
                int nX = x+dx[i];
                int nY = y+dy[i];
                int nL = l+1;
                
                if (checkValid(nX,m) && checkValid(nY, n) && visited[nY][nX] == -1 && maps[nY][nX]==1){
                    visited[nY][nX] = nL;
                    q.offer(new Node(nX,nY,nL));
                }   
            }
        }
          
        return visited[n-1][m-1];
    }
                
    boolean checkValid(int target, int max){
        if (target<0 || target>(max-1)) return false;
        return true;
    }
            
}
```
- dx, dy 사용으로 가독성 향상, 중복 해소
- Node에 level 필드 사용하지 않고, visited에 기록하는 형식, 현재 level도 visited를 참조해서 알 수 있음(어차피 이미 방문한 지점이 큐에서 poll 되므로)
