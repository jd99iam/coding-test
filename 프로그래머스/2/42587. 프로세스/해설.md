푸는 방법을 생각할 때 

1. 실행 대기 큐(Queue)에서 대기중인 프로세스 하나를 꺼냅니다.
2. 큐에 대기중인 프로세스 중 우선순위가 더 높은 프로세스가 있다면 방금 꺼낸 프로세스를 다시 큐에 넣습니다.
3. 만약 그런 프로세스가 없다면 방금 꺼낸 프로세스를 실행합니다.
  3.1 한 번 실행한 프로세스는 다시 큐에 넣지 않고 그대로 종료됩니다.

문제에서 제시한 위 방법을 보고, 2번 과정을 어떻게 하면 좋을지 고민하다가 
HashMap<우선순위, 큐에 남은 개수> 형태로 맵을 만들고, 큐에서 꺼낼 때마다 자신보다 우선순위가 높은 프로세스가 남아 있는지 맵을 통해 확인하는 방식을 생각했다. 
왜냐하면 프로세스는 최대 10^2 개 , 우선순위는 1-9 이므로 10^3 안에서 해결될거라 생각했다. 

다른 사람의 풀이 중 맘에 들었던 풀이는 
HashMap 이 아닌 PrioriryQueue 를 사용한 것이다. 

```java
import java.util.*;

class Solution {
    public int solution(int[] priorities, int location) {
        int answer = 1;
        PriorityQueue p = new PriorityQueue<>(Collections.reverseOrder());;

        for(int i=0; i<priorities.length; i++){
            p.add(priorities[i]);
            System.out.println(p);
        }
        System.out.println(p);

        while(!p.isEmpty()){
            for(int i=0; i<priorities.length; i++){
                if(priorities[i] == (int)p.peek()){
                    if(i == location){
                        return answer;
                    }
                    p.poll();
                    answer++;
                }
            }
        }

        return answer;
    }
}
```
출처 : https://school.programmers.co.kr/learn/courses/30/lessons/42587/solution_groups?language=java

PriorityQueue 를 큰 수 가 우선순위가 높게 생성하고 프로세스의 우선순위를 전부 넣는다. 
우선순위 큐를 peek 해서 확인한 값은 현재 가장 높은 우선순위가 된다. 
priorites 를 순회하며 해당 값이 있으면 프로세스를 처리하고, 큐에서 poll 해주고, answer (처리 순서) 를 1 더해준다. 
만약 그 때 인덱스 값이 location 이면 그 때의 answer 를 리턴한다. 

priorites 를 순회하면서 현재 최우선 순위인 것만 처리하기 때문에 후우선 순위인 걸 큐의 맨 뒤로 넣는 (문제 설명) 과 같게 동작하는 효과이다 

priorites 는 최대 10^2개 원소를 갖고 
while 이 도는 건 while 이 한번 돌 때 마다 우선순위 하나에 대해 처리가 다 된다. 
첫번째 반복 : 우선순위 9 전부 처리 
두번째 반복 : 우선순위 8 전부 처리
..
이런 식이니까 결국 최대 10번 돌게 된다. 
따라서 역시 10^3 의 시간복잡도를 갖는다. 

