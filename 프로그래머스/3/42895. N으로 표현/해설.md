이 문제는 혼자서 푸는데 실패해서 답을 보고 풀었다. 

# 실패한 방법 
DP 문제라는 걸 알기 때문에 DP로 접근하려고 했다. 
시도한 방법은 +를 예로 들어보면
`dp(N, number)` 가 number를 N으로 표현하는데 필요한 N의 개수라고 하면
`dp(N, number) = dp(N , k) + dp(N, number-k);` 
이런 식으로 `k를 표현하는데 필요한 N의 개수 + (number-k)를 표현하는데 필요한 N의 개수` 이런 발상을 먼저 했다. 
+, -, *, / 전부 고려해줘서, `number` 를 만드는데 가능한 조합을 사칙연산별로 구해서 컬렉션에 넣고 stream을 돌리면서 그중에 가장 작은값을 쓰려고 했다. 

```
+ : 1, 2, 3, ,,, number/2 까지 k가 돌면서 구한다
* : number의 약수만 k 가 돌면서 구한다 
```
그래서 +, * 에 대해서는 이런 식으로 생각을 했는데, -, / 가 문제가 된다. 
```
1조 - (1조 - number)  = number
(1조*number)/1조 = number
```
이렇게도 가능하기 때문에 단순히 범위를 지정해서 할 수가 없었다.
이 상황에서 어떻게 해야 할지 계속 고민해도 답이 안나와서 해설을 봤다. 

# 통과한 풀이 
```java
/**

최대 8개의 N 사용 가능 

N을 n개 사용해서 만들 수 있는 수는 
n = i + j 라고 할 때 

N n 개 나열 NNNN 형태 
(N i개) + (N j개)
(N i개) - (N j개)
(N i개) * (N j개)
(N i개) / (N j개)

이렇게 만든 것 중 number 가 있는지 확인 

n은 최대 8이라는 제약이 있기 때문에 가능

**/

import java.util.*;

class Solution {
    
    public int solution(int N, int number) {
        
        System.out.printf("N : %d , number : %d", N, number);
        
        List<Set<Integer>> memo = new ArrayList<>(); 
        // 인덱스 편하게 구성하기 위해 0번째는 사용하지 않고 초기화만 하고 1~8번째 사용
        
        for (int i=0; i<=8; i++){
            memo.add(new HashSet<>());
        }
        
        // memo.get(i) 는 N을 i개 사용해서 만들 수 있는 수들의 리스트 
        for (int i=1; i<=8; i++){
            Set<Integer> currentSet = memo.get(i);
            
            // NNN 형태로 숫자 이어붙이는 경우 
            StringBuilder sb = new StringBuilder();
            for (int j=1; j<=i; j++){
                sb.append(String.valueOf(N));
            }
            currentSet.add(Integer.parseInt(sb.toString()));
            
            for (int j=1; j<i; j++){
                int k = i-j;
                
                Set<Integer> jList = memo.get(j);
                Set<Integer> kList = memo.get(k);
                
                for (Integer jNum : jList){
                    for (Integer kNum : kList){
                        currentSet.add(jNum+kNum);
                        currentSet.add(jNum-kNum);
                        currentSet.add(jNum*kNum);
                        if (kNum>0){
                            currentSet.add(jNum/kNum);    
                        }
                    }
                }
            }
            
            if (currentSet.contains(number)) {
                return i;
            }
            
        }
        
        return -1;
    }
}
```

내가 이런 방식을 떠올리지 못한 건 문제의 제약조건에 대해 고민해보지 않아서라고 생각한다.

```
제한사항
  N은 1 이상 9 이하입니다.
  number는 1 이상 32,000 이하입니다.
  수식에는 괄호와 사칙연산만 가능하며 나누기 연산에서 나머지는 무시합니다.
  최솟값이 8보다 크면 -1을 return 합니다.
```
여기서 `최솟값이 8보다 크면 -1을 return 합니다.` 를 보고 그냥 그런갑다.. 하고 넘어갔다. 
위의 풀이를 보면 어차피 최대 8개만 사용하니까 
> 1개 사용하는 경우 : dp(1) -> 2개 사용하는 경우 : dp(1) 사칙연산 dp(1) -> 3개 사용하는 경우 : dp(1) 사칙연산 dp(2) + dp(2) 사칙연산 dp(1)  -----> 8개 사용하는 경우 : ~~ 

이런 식으로 구해나가면서 구한 값중에 number랑 일치하는게 있는지 확인한다. 
N이 최대 8개까지만 가능하다는 것에 집중했으면 이런 방법을 떠올렸을 것 같다. 

`데이터 n개가 주어질 때 n 은 최대 10000 개` 이런 제약조건만 시간복잡도 영향이 있다는 그런 고정관념에 N이 최대 8개까지 가능하다는 제약조건을 유심히 보지 않은 것 같다. 




