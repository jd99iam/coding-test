PriorityQueue 는 Collection 인터페이스를 상속한다. 따라서 remove 메서드가 구현되어 있다. 
PriorityQueue에서 `poll()` 로 우선순위에 따라 원소를 제거할 수도 있지만 `remove(대상)` 으로 원하는 원소를 제거할 수도 있다는 것이다. 

```java
import java.util.*;

class Solution {
    public int[] solution(String[] operations) {
        Queue<Integer> minpq = new PriorityQueue<>();
        Queue<Integer> maxpq = new PriorityQueue<>(Collections.reverseOrder());

        for (String operation : operations) {
            if (operation.startsWith("I ")) {
                int n = Integer.parseInt(operation.substring(2));
                minpq.offer(n);
                maxpq.offer(n);
            } else if (!minpq.isEmpty() && operation.equals("D -1")) {
                maxpq.remove(minpq.poll());
            } else if (!maxpq.isEmpty() && operation.equals("D 1")) {
                minpq.remove(maxpq.poll());
            }
        }

        if (minpq.isEmpty() && maxpq.isEmpty()) {
            return new int[]{0, 0};
        }

        return new int[]{maxpq.poll(), minpq.poll()};
    }
}
```
`remove()`를 활용하면 이렇게 내 소스보다 훨씬 간단하게 짤 수 있다.

다만 `remove()` 메서드의 최악시간복잡도는 O(N) 이라는 것에 주의해야 한다. 
원소를 찾는 데 O(N), 제거 후 재정렬(heapify) 과정이 O(logN)이다. 
