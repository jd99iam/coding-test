- dfs로도 풀 수 있지만 bfs 가 더 간단하다.

```java

class Solution {
    public int numIslands(char[][] grid) {
        int height = grid.length;
        int width = grid[0].length;

        // boolean 초기값 false
        boolean[][] visited = new boolean[height][width];

        int count = 0;
        for (int i = 0; i < height; i++) {
            for (int j = 0; j < width; j++) {

                if (!visited[i][j] && grid[i][j] == '1') {
                    bfs(i, j, visited, grid, height, width);
                    count += 1;
                }

            }
        }
        return count;
    }

    public static class Node {
        int h;
        int w;

        public Node(int h, int w) {
            this.h = h;
            this.w = w;
        }

    }

    public static void bfs(int h, int w, boolean[][] visited, char[][] grid, int height, int width) {

        ArrayDeque<Node> queue = new ArrayDeque<>();
        Node node = new Node(h, w);
        queue.offer(node);

        int[] dh = new int[] { 0, 0, 1, -1 };
        int[] dw = new int[] { 1, -1, 0, 0 };

        while (!queue.isEmpty()) {
            Node current = queue.poll();
            int curH = current.h;
            int curW = current.w;

            visited[curH][curW] = true;

            for (int i = 0; i < 4; i++) {
                int nextH = curH + dh[i];
                int nextW = curW + dw[i];
                if (0 <= nextW && nextW < width && 0 <= nextH && nextH < height && grid[nextH][nextW] == '1'
                        && !visited[nextH][nextW]) {
                    // bfs를 구현할 때는 큐에 넣을 때 visited 에 추가를 해줘야 중복을 막을 수 있다. 
                    visited[nextH][nextW] = true;
                    queue.offer(new Node(nextH, nextW));
                }
            }
        }
    }
}


```

- 상, 하, 좌, 우 방문을 dx, dy 배열을 만들어 간단하게 작성했다. 시간 절약, 실수 방지에 도움이 될 것 같다.