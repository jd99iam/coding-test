# 시간 복잡도 
- 제약조건에서 노드 개수가 최대 10^5이고 순회는 O(n) 이므로 10^8 을 초과하지 않아 dfs 로 풀어도 된다.


```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 * int val; 
 * TreeNode left;
 * TreeNode right;
 * TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if (root == null){
            return null;
        }
        TreeNode leftResult = lowestCommonAncestor(root.left, p, q);
        TreeNode rightResult = lowestCommonAncestor(root.right, p, q);
        
        if (root.val == p.val || root.val == q.val){
            return root;
        }
        if (leftResult!=null && rightResult!=null){
            return root;
        }
        if (leftResult!=null){
            return leftResult;
        }
        if (rightResult!=null){
            return rightResult;
        }
        return null;
    }
}
```
- 두 자식 모두 반환값 null : root 도 null 리턴
- 두 자식 중 하나만 반환 : root 도 똑같이 반환 
- 두 자식 모두 반환 : root 자신 반환 
- root 값이 p 도는 q : root 자신 반환